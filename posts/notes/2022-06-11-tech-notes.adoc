---
title: Tech Notes
tags: technology
---

== technologies
=== AWS Device Farm
* https://www.youtube.com/watch?v=UiJo_PEZkD4
* https://www.youtube.com/watch?v=PRA1WlR0nvU
 
=== Docker
* https://docs.docker.com/get-started/overview/

==== Docker Overview
* seperate applications from infrastructure
* manage infra in same ways you manage applications

==== The Docker Platform
* run application in loosely isolated environment called container
* isolation + security => run many containers on a given hsot
* share containers, containers contain everything needed to run the application

==== What can I use Docker for? 
* fast, consistent delivery of applications
* work in standardied environments
* highly portable workloads
* alternative to virutal machines

==== Docker architecture
* client-server architechture
* Docker client talks to Docker daemon
** daemon does heavy lifting of bulding, running, distributing Docker containers
** client and daemen can run in same system, or you can connect Docker client to remote Docker deemon
** client and daemen communicate using REST API, over UNIX sockets or network interface 
* Docker Compose: Docker cilent that lets you work with applications consisting of a set of containers

image::/images/tech-notes/docker.svg[]
From the Docker website

* Docker daemen: `dockerd` listens for Docker API requests and manages Docker objects such as images, containers, networks, volumes. can also communicate with other daemens
* Docker client: `docker` primary way that Docker users interact with Docker. `docker run`: client sends these commands to `dockerd`. uses the Docker API, can communicate with more than one daemen
* Docker Desktop: desktop application
* Docker registries: stors Docker images (like GitHub, there's a Docker Hub)
* Docker objects: 
** Images: read only template with instructions on creating a Docker container. An image is usually based on another image + customization. to create your own image, you been a Dockerfile. each instruction in the Dockerfile creates a layer in the image. when you rebuild the image, only those layers which have changed are rebuilt.
** Containers: runnable instance of an image. by default, a container is well isolated from other containers and its host machine. when a container is removed, any changes to its state that are not stored in persistent storage disappear

=== REST API
* https://www.liquidweb.com/kb/what-is-rest-api-an-overview/

==== What is REST
* REST => REpresentational State Transfer
* take advantage of existing HTTP protocols
* can return multiple formats (not constrained to just XML)

==== What is RESTful API
* API: application programming interface; method of interaction between two systems
* REST API design style state:
** each entity has unique identifier
** standard methods used to read and modify data 
** provide support for different resources
** interactions should be stateless
* REST adheres to these rules:
** Client-Server Architecture: interface is seperate from server-side data repository.
** Detachment: client connections not stored on server between requests
** Cacheability: where can client store responses
** Multi-level: API should work at any level

==== HTTP Components
* request structure
** request line, header fields, body
* response structure
** status line, header fields, body
* four minimum operations:
** receiving data from server, adding new data to server, modification of data on server, deletion of data on server
* crud: create, read, update, delete => post, get, put, delete

==== HTTP Status Codes
* 1XX: Information
* 2XX: Success
* 3XX: Redirect
* 4XX: Client Error
* 5XX: Server Error

==== REST API Subtypes
* XML, JSON, GraphQL

=== Appium
* https://appium.io/docs/en/about-appium/intro/?lang=en

==== Introduction to Appium
* tool for automating native, mobile web, hybrid applications on iOS mobile, Android mobile and Windows desktop platofmrs. 
** native: written using the respective SDK
** mobile web app: web apps accessed through the browser
** hybrid app: have wrapper around a "webview" -- native control that enables interaction with web content
* write tests against multiple platforms using same API => code reuse

==== Philosophy
* you shoudln't have to recompile your app or modify it in any way in order to automate it
* you shoudln't be locked into a specific language or framework to write and run tests
* mobile automation framework shoudln't reinvent the wheel when it comes to automation APIs
* moblie automation framework should be open source

==== Appium design
* using vendor-provided automation frameworks => XCUITest, UIAutomation, UIAutomator/UIAutormater2
* wrap the vendor-provided framework in one API (WebDriver API)
* Appium & WebDriver are automation libraries

==== Appium Concepts
* Client/Server Architechture
* Session
* Desired Capabilities
* Appium Server
* Appium Clients
* Appium Desktop
