---
title: "Paper: Forward Build Systems, Formally"
date: 2022-05-28
tags: verification
---

Sarah Spall, Neil Mitchell, and Sam Tobin-Hochstadt. 2022. For-
ward Build Systems, Formally. In Proceedings of the 11th ACM SIG-
PLAN International Conference on Certified Programs and Proofs
(CPP ’22), January 17–18, 2022, Philadelphia, PA, USA. ACM, New
York, NY, USA, 13 pages. https://doi.org/10.1145/3497775.3503687

* build systems have recieved little focus on their correctness
* what does it mean for a forward build system to be correct => behave identically to simply executing the programmer-specified commands in order
** real build systems also have optimizations

== 1 Introduction
* most important features: incrementality and parallelism => MAKE requires user to declare targets to build, what those targets depend on and how to build those targets
* getting correct dependecies on a project is hard => incorrect or omitted dependencies leads to missed opportunites for parallelism or outright incorrect results
* alternative to MAKE: forward build system => user writes a program taht say show to build their software project, without declaring targets or dependencies
** using system tracing, runs each command and records the files the command read or wrote during its execution. 
** during rebuild, uses this information to decide if it should run this command again

*RATTLE*: provides support for implicit parallelism via speculation and checks if commands in a forward build system are valid or in conflict with each other via hazards

* hazards: stating correctness for Rattle in a way not possible for prior build systems: a build process that writes to some of the inputs to the build => can't rely on remembering past commands because no way to know about past state

> A forward build system is correct if, for every build, it either produces the same result as running the commands in order, or reports an error.


== 2 Rattle
* uses tracing to record which files are written to and read from by the command and contents of those files
* if Rattle sees a command which ran before wtih current value of inputs and outputs => skips command
* if Rattle sees command with which ran with current inputs, if Rattle has access to copy of outputs, it puts outputs where command would put them
* else, will run afresh with tracing
* single-threaded => overcome with speculation => predicts commands that are likley to be needed in future and unlikely to conflict, and runs them before script requests them
** based on what ran previously or hazards

=== 2.1 Hazards
* *read-before-write hazard*: one command reads a file that a later command writes to. 
** on next rebuilds, first command needs to run again because second command wrote to its dependency
* *write-before-write hazard*: a command writes to a file and a later command also writes to that file. 
** on next rebuilds, first command will need to run again because second command changed it's output, and the second command will likely be triggred to run again
* *speculative write-before-read hazard*: if command runs speculatively and hasn't been marked as required yet, it is speculated. if speculated command writes to a file later read by required command, RAttle has run commands in the wrong order

=== 2.2 Assumptions
for a hazard-free build to reach a fixed point, Rattle makes certain assumptions that it does not check:

* *determinism of commands*: assumes all commands are deterministic; non-deterministic commands => different result each time it runs
* *disjoint reads and writes*: commands do not write to their own inputs (all writes first truncate); otherwise Rattle cannot capture true value of inputs since the capture occurs only after the command has completed
* *tracing data is correct*

=== 3.3 Preconditions and Simplifications
* builds cannot contain duplicate commands; if a command appears more than once it will be skipped on more appearances
* builds are static lists: monadic builds are supported (previous commands influence future commands), but they complicate the proof
* commands are run sequentially

