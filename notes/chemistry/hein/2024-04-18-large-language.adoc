---
title: Large language models for chemistry robotics
---

=== https://link.springer.com/article/10.1007/s10514-023-10136-2[Large language models for chemistry robotics]

==== abstract
* automatic iterative prompting with program verification => ensure syntactially valid programs
** combat data-scarce DSL
* constrained task/motion planning problem => PDDLStream solvers

==== introduction
* self-driving labs => make manual experimentation easier
** specialized hardware has been created for chemistry labs, but paper argues for general purpose robots => maximize use of existing resources/more configurable(?)
* challenges:
** adhere to strict syntax rules
*** task-plan verification => increases chance robot can reach desired goal
*** LLMs bad when just randomly trying to generate (without constraints/context/rules) because of lack of domain-specific knowledge
*** iterative prompting: LLM verifies candidate plans with rules of DSL as input
* safety concerns: high-level (material synthesis, task planning, experiment description), low-level (moving glassware around)

* CLAIRIFY:
** natural language input => structured plan => low-level robot
** XDL => instructions for Franka robot via. TAMP
** method:
*** rule-based iterative verifier => improves zero-shot task plan generation
*** TAMP level: constrained task/motion planning => PDDLStream solver => avoid spillage
** adding constraints to robots DoF: 8 DoF > 7 DoF accuracy

* advancement from finite state machine (memory wise? step wise?)
** can plan/perform long-term/multistep chemistry projects
** improvements:
*** at chemistry task level: online visual feedback to estimate progrss or task execution
*** robot motion planning/skill level: robot can adapt to uncertainties/refinement using visual feedback

==== related work
* self driving labs: ai and lab automation
* specialized hardware: chemputer
* general-purpose hardware
* reliance on predefined tasks + motion plans without constraint satisfaction => limits flexibility in new/dynamic environments
** pick and place in static/hand-tuned environments => this framework resolves this gap => long-horizon instructions + constraint satisfaction + scene-aware planning system

* large language models for chemistry
** specialized language models: MolT5, Chemformer, Galactica
** after GPT-3: bayesian optimization, use external chemistry tools, synthesize molecules via documentation

* LLMs with external knowledge
** generate code with LLMs: correctness of code is not known
** LLM-augmenter: improves LLM outputs by giving access to external knowledge + automatically revising prompts

==== misc points
* "We tried the same experiment with code-davinci-002; the outputs generally had more structure but were still nonsensical. This result suggests the LLM does not have the knowledge of the target language and including the language description in the prompt is essential to generate an unfamiliar language."
* depending on task, like solubility, recrystallization, the process is iterative + don't know the exact values we need when te program is initially generated
* the better the error message, the better the fix
* LLMs are robust to different writing styles
* PDDLStream: inhibits framework from being reactivein dynamic environment => learning-based search heuristics for PDDLStream could overcome this
* constrained motion planning, extra DoF => increase physical robot's success rate (not able to run in realtime)

==== PDDLStream
* defined by a tuple (P, A, S, O, I, G):
** predicates
** actions (with precondition and effects)
** streams
** distinguishes PDDLStream problem from normal PDDL
** conditional sampler that yield objects => satisfy specific constraints
** initial objects
** initial state
**  goal state
* seems similar to constraint solving problem
* goal is to fidm sequence of logical actions+continuous motion trajectory starting from initial state until all goals are satisfied
** streams generate objects from continous variables that satisfy conditions
* solved by invoking clasical PDDL planner with optimistic instantiation of streams (Fast Downward)
