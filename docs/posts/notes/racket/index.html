<!doctype html>
<html lang="en">
  <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Lucy H | λ Racket Shenanigans</title>
        <link rel="stylesheet" href="../../../css/main.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
        <!-- and it's easy to individually load additional languages -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/scheme.min.js"></script>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/onedark.min.css">
        <script>hljs.highlightAll();</script>

        <link rel="preconnect" href="https://www.googletagmanager.com" />
        <link rel="preconnect" href="https://www.google-analytics.com" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-KDGPVMHC9Q"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-KDGPVMHC9Q');
        </script>

        <!-- Twitter -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@hoalycu" />
        <meta name="twitter:creator" content="@hoalycu" />
        <meta property="og:title" content="λ Racket Shenanigans" />
        
        
        <meta property="og:url" content="/posts/notes/racket" />
        
        

        <!-- basic favicon -->
        <link rel="icon" href="../../../images/android-chrome-384x384.png" /> 
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../images/android-chrome-384x384.png">
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../images/android-chrome-384x384.png">
        <link rel="apple-touch-icon-precomposed" href="../../../images/android-chrome-384x384.png">
    </head>


        <body>
        <header>
            <div class="logo">
                <a href="../../../">
                <img src="../../../images/android-chrome-384x384.png" alt="Me">
                </a>
            </div>
        </header>

        <main role="main">
            <h1>λ Racket Shenanigans</h1>
            <div>
  
    <div class="header">
        Posted on January  1, 2022
        
    </div>
<div class="tags">
    
    Tags: <a title="All pages tagged 'learning'." href="../../../tags/learning/index.html">learning</a>
    
</div>
    <div>
        <div class="paragraph">
<p><a href="https://beautifulracket.com/stacker/recap.html">awesome book on creating
languages in racket</a></p>
</div>
<div class="paragraph">
<p>These are my notes on creating programming languages with Racket.</p>
</div>
<div class="sect1">
<h2 id="_making_funstacker_a_functional_version_of_stacker">making funstacker, a functional version of stacker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find the full tutorial
<a href="https://beautifulracket.com/funstacker/">here</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (read-syntax path port)
  (define src-lines (port-&gt;lines port))
  (define src-datums (format-datums '~a src-lines))
  (define module-datum `(module funstacker-mod "funstacker.rkt"
                          (handle-args ,@src-datums)))
  (datum-&gt;syntax #f module-datum))
(provide read-syntax)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>format-datums</code> takes the list of lines and changes it into data.</p>
</li>
<li>
<p>for funstacker, we just want to return the input as <code>1 2 + 3 *</code> and
change it into <code>(handle 1 2 + 3 *)</code>.</p>
</li>
<li>
<p>that is what <code>(handle-args ,@src-datums)</code> is doing.</p>
</li>
<li>
<p>now we need to make the <code>handle-args</code> function.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_forfold">for/fold</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(for/fold ([sum 0])
          ([int (list 1 2 3 4 5 6 7 8 9 10)])
          (+ sum int))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>for/fold</code> iterates over a list of values and each pass of the loop also
returns an accumulator. The value of the accumulator is replaced with a
new value. The loop ends when the iterator runs out of values. The
return value is the final value of the accumulator.</p>
</div>
<div class="paragraph">
<p>For the example above, the accumulator is <code>sum</code> and iterator is <code>int</code>.</p>
</div>
<div class="paragraph">
<p><code>for/fold</code> has two mandatory parts, and two optional parts. 1. at least
one accumulator needs to be defined and every accumulator needs to have
an inital value. 2. at least one iterator needs to be defined. 3.
(optional) guard expression, which limits the iteration with a test
condition. 4. (optional) sequence constructor <code>in-list</code>. any sequence
can be used directly as source of iterator values, including any list.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_making_bf_the_next_step">making bf, the next step!</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://beautifulracket.com/bf/">tutorial here</a></p>
</div>
<div class="sect2">
<h3 id="_intro">intro</h3>
<div class="paragraph">
<p>The essential parts of a language are: - reader - expander</p>
</div>
<div class="paragraph">
<p>But now we want to add grammer, basically allow us to specify the
structure of a language. We need two new pieces: - parser - tokenizer</p>
</div>
<div class="paragraph">
<p>To use bf in racket: <code>#lang bf-demo</code></p>
</div>
<div class="sect3">
<h4 id="_how_bf_works">how bf works</h4>
<div class="ulist">
<ul>
<li>
<p>when starting up: create array of bytes in memory (each byte
initialized to 0) and pointer into that array (initialized to the 0
position).</p>
</li>
<li>
<p>the current byte is the byte in the array at the location indicated by
the pointer.</p>
</li>
<li>
<p>there are 6 operations:</p>
<div class="ulist">
<ul>
<li>
<p>&gt; increase pointer position by one</p>
</li>
<li>
<p>&lt; decrease pointer position by one</p>
</li>
<li>
<p></p>
<div class="ulist">
<ul>
<li>
<p>increase the value of the current byte by one</p>
</li>
</ul>
</div>
</li>
<li>
<p></p>
<div class="ulist">
<ul>
<li>
<p>decrease the value of the current byte by one</p>
</li>
</ul>
</div>
</li>
<li>
<p>. write current byte to stdout</p>
</li>
<li>
<p>, read a byte from stdin and store it in the current byte
(overwriting the existing value)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also a looping construct <code>[…​]</code> that will repeat code within
the brackets until the current byte is zero.</p>
</div>
<div class="paragraph">
<p>Recall the two functions each language needs: - reader: converts source
file from string of characters into parenthesized S-expressions.
<code>read-syntax</code> - expander: determines how the S-expressions correspond to
Racket code. Starts with macro called #%module-begin</p>
</div>
<div class="paragraph">
<p>Clean, well-structured S-expressions makes writing an expander much
easier.</p>
</div>
<div class="paragraph">
<p>The way we can convert any well-specified programming language into
S-expressions is by using a grammar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammars_and_parsers">grammars and parsers</h3>
<div class="sect3">
<h4 id="_parsing_and_parse_trees">parsing and parse trees</h4>
<div class="paragraph">
<p>parsing: converting source code from a format for humans into one
optimized for a computer. - the data structure that emerges from the
parser is a parser tree.</p>
</div>
<div class="paragraph">
<p>In Racket, a parse tree can be notated as an S-expression. A parse tree
describes structure of code, but doesn’t tell us how the code will
actually run.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">if y &gt; 0:
  x / y
else:
  print("nope")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">'(if (&gt; y 0)
     :
     (/ x y)
     else:
     (print "nope"))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(if (&gt; y 0)
  (/ x y)
  (print "nope"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Racket looks similar to the parse tree!</p>
</div>
</div>
<div class="sect3">
<h4 id="_parsing_power_tool_a_grammar">parsing power tool: a grammar</h4>
<div class="paragraph">
<p>It makes more sense to use a parser generator to make a parser from a
specification of the structure of the language (a grammar). - a grammar:
way of notating the structure of every possible program written in that
language. - grammar based parser is like regular expression, but it
produces parse trees.</p>
</div>
<div class="paragraph">
<p><strong>why we should write a grammar vs. make a parser by hand.</strong> - we can use
grammars that already exist, like Python’s grammar, to make a
Python-like language. - a grammar is a reality check; if we can write a
grammar, chances are good that the language will work out. If we can’t,
it’s a warning our language will have wrinkles (Markdown) - easier to
amend a grammar then hand-crafted parser.</p>
</div>
<div class="paragraph">
<p><strong>why we can’t parse with regular expressions</strong> - regular expressions
treat strings as flat, sequential data</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_notation">grammar notation</h3>
<div class="ulist">
<ul>
<li>
<p>consists of production rules, written one per line. On the left of
each rule is the name of the structural element. A colon goes in the
middle of the rule. This notation style is known as EBNF. On the right
of each rule, we have a pattern for that element.</p>
</li>
<li>
<p>the right side can include: literal strings, classes of strings, names
of other production rules. Multiple possibilities are separated by |</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_applying_a_grammar">applying a grammar</h4>
<div class="ulist">
<ul>
<li>
<p>parser takes string of source code</p>
</li>
<li>
<p>starting with first production rule, parser tries to match source code
to pattern on the right.</p>
</li>
<li>
<p>if the pattern contains names of other rules of grammar, parser
recursively tries to match those rules, again using patterns on the
right.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This process continues until one of two things: - the parser decomposes
source code into something that can’t be further decomposed →
terminals. A parse tree is returned (the leaves of a parse tree are
always terminals) - the parser can’t find any way to decompose source
code into terminals; parse fails. It’s trial and error (parser could try
lots of unsuccessful paths)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ambiguous_grammars_you_could_write_a_grammar_that_can_produce_more">ambiguous grammars - you could write a grammar that can produce more</h3>
<div class="paragraph">
<p>than one valid parse tree for the same string - but you should avoid
this</p>
</div>
<div class="sect3">
<h4 id="_groups_and_multiples_in_patterns">groups and multiples in patterns</h4>
<div class="paragraph">
<p>a grammar for stacker</p>
</div>
<div class="literalblock">
<div class="content">
<pre>stacker-program : "\n"* instruction ("\n"+ instruction)*
instruction     : integer | func
integer         : ["-"] digit+
digit           : "0" | "1" | "2" | "3" | "4"
                | "5" | "6" | "7" | "8" | "9"
func            : "+" | "*"</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>parenthesizes create subsequences.</p>
</li>
<li>
<p>* means zero or more</p>
</li>
<li>
<p>+ means match one or more of the preceding item</p>
</li>
<li>
<p>[] means zero or 1 of the enclosed item</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>4
8
+
3
*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>'(stacker-program
  (instruction (integer (digit "4")))
  "\n"
  (instruction (integer (digit "8")))
  "\n"
  (instruction (func "+"))
  "\n"
  (instruction (integer (digit "3")))
  "\n"
  (instruction (func "*")))</pre>
</div>
</div>
<div class="paragraph">
<p>notes about how the parse tree lines up with the grammar: - each node in
parse tree corresponds to production rule, starting with name of rule
followed by elements that matched the pattern for that rule - rules that
rely on other rules leads to nesting. - every character that appeared in
original source string appears in parse tree.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_parser">the parser</h3>
<div class="ulist">
<ul>
<li>
<p>bf is just a list of operations and loops</p>
<div class="ulist">
<ul>
<li>
<p>so the first line means: either <code>bf-op</code> or <code>bf-loop</code> and zero or more
of</p>
</li>
</ul>
</div>
</li>
<li>
<p>now define bf-op and bf-loop</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>bf-program: (bf-op | bf-loop)*
bf-op: "&gt;" | "&lt;" | "+" | "-" | "." | ","
bf-loop: "[" (bf-op | bf-loop)* "]"</pre>
</div>
</div>
<div class="paragraph">
<p>and that’s the grammar for bf! There are other ways to define the
grammar but this is the easiest because <code>bf-program</code> only appears ones
and it is the least number of rules.</p>
</div>
<div class="sect3">
<h4 id="_converting_a_grammar_to_a_parser">converting a grammar to a parser</h4>
<div class="ulist">
<ul>
<li>
<p>we will use a parser-generating language called <code>brag</code> that takes a
list of production rules and turns those into a working parser.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_tokenizer">the tokenizer</h3>
<div class="ulist">
<ul>
<li>
<p>source string is converted to tokens</p>
</li>
<li>
<p>tokenizer sits between source string and parser</p>
</li>
<li>
<p>a tokenizer is optional: if we don’t use a tokenizer, then every
character that appears in the source code counts as a token.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some tasks that are easily handled by the tokenizer? - meaningless
strings in source code can be removed - strings that represent a value
can be labeled with a generic token type - strings that should be
handled literally can just pass through</p>
</div>
<div class="paragraph">
<p>Downside to a tokenizer - substrings removed (like comments) are
invisible to the parser. - tokens are indivisible; once we fuse a
substring into a token, it can’t be decomposed further by the parser.
big tokens can be convenient because they reduce complexity, but they
also reduce flexibility.</p>
</div>
<div class="sect3">
<h4 id="_designing_the_bf_tokenizer">designing the bf tokenizer</h4>
<div class="paragraph">
<p>The bf grammar omits one detail: that any characters besides the eight
used should be ignored. - the bf tokenizer is simple: pass through eight
characters intact and toss out everything else</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_a_reader_with_a_tokenizer">writing a reader with a tokenizer</h4>
<div class="ulist">
<ul>
<li>
<p>instead of manually reading in strings of code from port, pass port to
make tokenizer, which returns function that reads characters from port
and generates tokens</p>
<div class="ulist">
<ul>
<li>
<p>make-tokenizer creates and returns a function next-token that parser
calls repeatedly to retrieve new tokens</p>
</li>
</ul>
</div>
</li>
<li>
<p>use those tokens with parse, to make parse-tree</p>
</li>
<li>
<p>create <code>module-datum</code> and put <code>parse-tree</code> inside</p>
</li>
<li>
<p>finally use <code>datum→syntax</code> to package code as syntax object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>tokenizing rules - helper function: lexer - each branch of lexer
represent a rule: right side of token-creating expression, left side is
pattern - each time <code>next-token</code> is called, <code>bf-lexer</code> will read as many
characters from port as possible while still matching a rule pattern
(greedy matching). - right side of rule with convert matched characters
into token, which is returned</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(require brag/support) ;; we need to so we can get lexer
(define (make-tokenizer port)
  (define (next-token)
    (define bf-lexer
      (lexer
       [(char-set "&gt;&lt;-.,+[]") lexeme] ; matches to one of our eight characters; we pass to lexeme (that thing we just matched)
       [any-char (next-token)])) ; think of else as else branch; we call next-token, basically skipping to the next available token
    (bf-lexer port))
  next-token)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>at the end, an <code>eof</code> is emitted, the lexer emits an <code>eof</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_making_the_expander_an_imperative_expander">making the expander: an imperative expander</h3>
<div class="ulist">
<ul>
<li>
<p>grammar tells us how many macros or functions we need</p>
</li>
<li>
<p>we need to handle three types of parse nodes: <code>bf-program</code>, <code>bf-op</code>,
<code>bf-loop</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Why grammar is awesome 1. each production rule in the grammar will have
a corresponding macro/function in the expander. 2. the name of the
production rule is the name of the macro/function 3. the pattern of the
production rule describes possible input to its corresponding macro or
function.</p>
</div>
<div class="paragraph">
<p>Choosing function vs macro: use function where we can, a macro where we
must - simple (return its args in a list or print them) → use function
- rearrange code in a way that a function can’t → macro</p>
</div>
<div class="paragraph">
<p><code>+[&gt;]</code> will be parsed into:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(bf-program (bf-op "+") (bf-loop "[" (bf-op "&gt;") "]"))</pre>
</div>
</div>
<div class="paragraph">
<p>our expander goes as follows: - call <code>bf-program</code> macro with two input
arguments: - <code>(bf-op "+")</code> - <code>(bf-loop "[" (bf-op "&gt;") "]")</code> - call
<code>bf-op</code> macro with one input: - <code>+'' - call <code>bf-loop</code> macro with three
input arguments: - </code>[” - ”]'' - <code>(bf-op "&gt;")</code> - call the <code>bf-op</code> macro
with one input argument: - ``&gt;''</p>
</div>
<div class="sect3">
<h4 id="_from_grammar_to_syntax_pattern">from grammar to syntax pattern</h4>
<div class="ulist">
<ul>
<li>
<p>syntax pattern is like a regular expression</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>bf-program</code> macro: <code>bf-program: (bf-op | bf-loop)*</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(bf-program OP-OR-LOOP-ARG ...)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bf-program</code> denotes literal identifier in the code, and is name of
macro. every element of a <code>define-macro</code> syntax pattern matches
literally</p>
</li>
<li>
<p>unless it’s in all caps.</p>
<div class="ulist">
<ul>
<li>
<p>pattern variable: can catch everything</p>
</li>
</ul>
</div>
</li>
<li>
<p>the …, similar to * quantifier. used after a pattern variable, the …
gathers al arguments that follow. can also match 0 arguments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Return value of a macro is a syntax template. - we return a void, which
discards the arguments. - <code>define-macro-cases</code> it’s like a cond</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_functional_expander">a functional expander</h3>
<div class="paragraph">
<p>We have two goals - avoid keeping state - avoid mutation</p>
</div>
<div class="paragraph">
<p>Tricky because bf by nature is imperative</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in funstacker we learned we can approximate behaviour of state
variables by turning them into accumulators with <code>for/fold</code></p>
</li>
<li>
<p>with functional programming idiom: model <code>bf</code> operations that take a
current array and pointer as input and return new array and pointer
values as output.</p>
</li>
<li>
<p>instead of storing state values outside the function, let the values
travel through the functions</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_restarting_the_expander">restarting the expander</h4>
<div class="ulist">
<ul>
<li>
<p>model new <code>bf</code> operations as functions that take two input arguments,
array and pointer, and return a new array and pointer.</p>
</li>
<li>
<p>we want return value of a <code>bf-func</code> to become input arguments of the
<code>next-bf-func</code>.</p>
<div class="ulist">
<ul>
<li>
<p>but <code>bf-func</code> only returns one value and <code>next-bf-func</code> needs two
values.</p>
</li>
<li>
<p>we cure this mismatch by using <code>apply</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>apply</code> - takes a function and list of values as input, and calls the
function while using those values as input arguments - these two
expressions are equivalent - kind of like takes the list apart.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(apply func (list arg1 arg2 arg3 arg4))
(func arg1 arg2 arg3 arg4)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the above example stipulates <code>func</code> is a run time function, not a
macro; macros cannot be passed as an argument to any higher order
function.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (fold-funcs apl bf-funcs)
  (for/fold ([current-apl apl])
            ([bf-func (in-list bf-funcs)])
    (apply bf-func current-apl)))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fold-funcs</code>: takes two input args, <code>apl</code> and a pointer; the return
value of <code>bf-func</code> and list of <code>bf-funcs</code></p>
</li>
<li>
<p>when <code>for/fold</code> starts, it creates an accumulator called <code>current-apl</code>
to hold current state of the <code>bf</code> program, and initializes it to the
<code>apl</code> argument passed as input.</p>
</li>
<li>
<p>then it iterates over the list of <code>bf-funcs</code></p>
</li>
<li>
<p>on each iteration it uses <code>apply</code> to pass <code>current-apl</code> as arguments
to the next <code>bf-func</code></p>
</li>
<li>
<p>once we run out of <code>bf-funcs</code>, the last value of <code>current-apl</code> becomes
the return value of the <code>for/fold</code> loop, and therefore the <code>fold-funcs</code>
function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>now we can write the macro for <code>bf-program</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define-macro (bf-program OP-OR-LOOP-ARG ...)
  #'(begin
      (define first-apl (list (make-vector 30000 0) 0))
      (void (fold-funcs first-apl (list OP-OR-LOOP-ARG ...)))))
(provide bf-program)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>we want to return code for two expressions; syntax object can only
represent one.</p>
</li>
<li>
<p>any time we want to return multiple expressions: use <code>begin</code></p>
<div class="ulist">
<ul>
<li>
<p>unlike <code>let</code>, <code>begin</code> does not create a new scope for variables, any
variables inside a <code>begin</code> are visible outside as well</p>
</li>
</ul>
</div>
</li>
<li>
<p>macro should not return a value, so pass result to a void.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>now we write the macro for <code>bf-loop</code>; there are two things to observe -
when <code>bf-loop</code> arrives at <code>fold-funcs</code>, it is expected to behave as
<code>bf-func</code>. So the return value of <code>bf-loop</code> macro has to be a function
that has two input args and 1 output arg. - <code>bf-loop</code> is mini <code>bf</code>
program that runs repeatedly until a certain condition is met.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define-macro (bf-loop "[" OP-OR-LOOP-ARG ... "]")
  #'(lambda (arr ptr)
      (for/fold ([current-apl (list arr ptr)])
                ([i (in-naturals)]
                 #:break (zero? (apply current-byte
                                       current-apl)))
        (fold-funcs current-apl (list OP-OR-LOOP-ARG ...)))))
(provide bf-loop)</code></pre>
</div>
</div>
<div class="paragraph">
<p>the last macro is <code>bf-op</code>, but instead of returning a self-contained
function, just return only the name of corresponding function → so
<code>fold-funcs</code> can <code>apply</code> a list of arguments to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_making_it_faster">making it faster</h4>
<div class="ulist">
<ul>
<li>
<p>this functional version is much slower because of the
<code>set-current-byte</code> func</p>
<div class="ulist">
<ul>
<li>
<p>we make a new array every time, which is 30k bytes, and the garbage
collector has to run more often to free up memory.</p>
</li>
<li>
<p>to make it faster we can just use the input array</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>

    </div>
    <p><a href="../../../archive/">◀ Back to posts</a></p>
</div>

        </main>
        
        <footer>
<center><p><a href="https://twitter.com/hoalycu" target="_blank">twitter</a> <a href="https://github.com/lhao03" target="_blank">github</a> <a href="https://www.linkedin.com/in/lucy-hao/" target="_blank">linkedin</a></p></center>
            Site powered by cats, 🍫 and 
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
