<!doctype html>
<html lang="en">
  <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Lucy H | 🦀 Rust notes</title>
        <link rel="stylesheet" href="../../../css/main.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
        <!-- and it's easy to individually load additional languages -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/scheme.min.js"></script>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/onedark.min.css">
        <script>hljs.highlightAll();</script>

        <link rel="preconnect" href="https://www.googletagmanager.com" />
        <link rel="preconnect" href="https://www.google-analytics.com" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-KDGPVMHC9Q"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-KDGPVMHC9Q');
        </script>

        <!-- Twitter -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@hoalycu" />
        <meta name="twitter:creator" content="@hoalycu" />
        <meta property="og:title" content="🦀 Rust notes" />
        
        
        <meta property="og:url" content="/posts/notes/rust" />
        
        

        <!-- basic favicon -->
        <link rel="icon" href="../../../images/android-chrome-384x384.png" /> 
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../images/android-chrome-384x384.png">
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../images/android-chrome-384x384.png">
        <link rel="apple-touch-icon-precomposed" href="../../../images/android-chrome-384x384.png">
    </head>


        <body>
        <header>
            <div class="logo">
                <a href="../../../">
                <img src="../../../images/android-chrome-384x384.png" alt="Me">
                </a>
            </div>
        </header>

        <main role="main">
            <h1>🦀 Rust notes</h1>
            <div>
    <div class="header">
        Posted on January  1, 2022
        
    </div>
<div class="info">
    
    Tags: <a title="All pages tagged 'learning'." href="../../../tags/learning/index.html">learning</a>
    
</div>
    <div>
        <div class="sect1">
<h2 id="_ch_1_getting_started">ch 1: getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Cargo.toml</code>: manifest file for Rust. - metadata and dependencies
<code>src/main.rs</code> where you write code.</p>
</div>
<div class="paragraph">
<p><code>cargo new</code>: generates a hello world program <code>cargo run</code>: run the
program</p>
</div>
<div class="sect2">
<h3 id="_adding_dependencies">adding dependencies</h3>
<div class="paragraph">
<p>you find libraries on crates.io, and packages are referred to as crates
<code>cargo-build</code> to install the dependency. - running this creates
<code>Cargo.lock</code>, which is a log of the exact versions of dependencies we
are using locally.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world">hello world</h3>
<div class="ulist">
<ul>
<li>
<p>indent with four spaces, not tab</p>
</li>
<li>
<p><code>println!</code> is a macro; <code>!</code> means you’re calling a macro.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_hello_cargo">hello cargo</h3>
<div class="paragraph">
<p>Cargo.toml <code>[package]</code>: indicates following statements are configuring a
package. - Cargo expects source files to live inside <code>src</code>. -
<code>cargo build</code>: builds executable in <code>target/debug</code> - <code>cargo run</code>: builds
and runs executable - <code>cargo check</code>: check code compiles, but doesn’t
build executable. - <code>cargo build --release</code>: your project is ready for
release, creates executable in <code>target/relesae</code> and is compiled with
optimizations</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ch_2_programming_a_guessing_game">ch 2: programming a guessing game</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>::</code> indicates the function is an associated function for that type.
<code>&amp;mut var</code> vs. <code>&amp;var</code> to make it mutable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ch_3_common_programming_concepts">ch 3: common programming concepts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_variables_and_mutability">3.1: variables and mutability</h3>
<div class="ulist">
<ul>
<li>
<p>by default, variables are immutable.</p>
</li>
<li>
<p>add <code>mut</code> to make it mutable.</p>
</li>
<li>
<p><code>const</code> are immutable always.</p>
</li>
<li>
<p>shadowing:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let x = 5; // x is 5 here
let x = x + 1; // x is 6 here
{
    let x = x * 2; // x is 12 here
}
// x is 6 here</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>with shadowing we can perform a few transformations on a value but
have the variable be immutable after those transformations have been
completed.</p>
</li>
<li>
<p>another difference between <code>mut</code> and shadowing is that by using <code>let</code>,
we are creating a new variable; we can change the type of the value and
reuse the same name.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_data_types">3.2: data types</h3>
<div class="sect3">
<h4 id="_scalar_types">scalar types</h4>
<div class="ulist">
<ul>
<li>
<p>single value: integers, floating-point numbers, Booleans, characters</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_integer_types">integer types</h5>
<div class="ulist">
<ul>
<li>
<p>to prevent integer overflow</p>
<div class="ulist">
<ul>
<li>
<p>wrap all modes with <code>wrapping_*</code> methods.</p>
</li>
<li>
<p>return <code>None</code> is there is overflow with <code>checked_*</code> methods.</p>
</li>
<li>
<p>return value and boolean indicating whether there was overflow with
<code>overflowing_*</code> methods.</p>
</li>
<li>
<p>saturate at the value’s min or max values with <code>saturating_*</code>
methods.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_floating_point_types">floating-point types</h5>

</div>
<div class="sect4">
<h5 id="_boolean_type">boolean type</h5>
<div class="ulist">
<ul>
<li>
<p>one byte <mark>#</mark># character type</p>
</li>
<li>
<p>4 bytes in size</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compound_types">compound types</h4>

</div>
<div class="sect3">
<h4 id="_tuple_type">tuple type</h4>
<div class="ulist">
<ul>
<li>
<p>fixed length</p>
</li>
<li>
<p>once declared, cannot grow or shrink in size</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let tup = (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;
let one = x.2;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>to get individual values, we use pattern matching or period and index.</p>
</li>
<li>
<p>tuple without any value, <code>()</code> is special type that has one vane, also
written <code>()</code>. the type is called <em>unit type</em> and the value is called
<em>unit value</em>.</p>
<div class="ulist">
<ul>
<li>
<p>expressions implicitly return unit value if they don’t return any
other value</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_arrays">arrays</h4>
<div class="ulist">
<ul>
<li>
<p>fixed length</p>
</li>
<li>
<p>allocated on stack</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; // a = [3, 3, 3, 3, 3];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_functions">3.2: functions</h3>
<div class="ulist">
<ul>
<li>
<p>statements: instructions that perform some action and do not return a
value</p>
</li>
<li>
<p>expressions: evaluate to resulting value</p>
</li>
<li>
<p>function definitions are statements</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn main() {
    let x = (let y = 6); // this does not work
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>let</code> statement does not return a value, so x has nothing to bind
to.</p>
</li>
<li>
<p>expressions include:</p>
<div class="ulist">
<ul>
<li>
<p>function calls, macro calls, <code>{}</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>adding <code>;</code> to the end of an expression turns it into a statement.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_funcs_with_return_values">funcs with return values</h4>
<div class="ulist">
<ul>
<li>
<p>don’t name return values, but declare type after an arrow</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>if we add a semicolon at the end of the return, we get an error.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_4_control_flow">3.4 control flow</h3>
<div class="ulist">
<ul>
<li>
<p>using loops; you can give loop labels.</p>
</li>
<li>
<p><code>break</code> and <code>continue</code> apply to the innermost loop at that point.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">'outer_loop: loop {
  loop {
    // something happens
    break;
    //something happens
    break 'counting_up;
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>returning values from loops</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let result = loop {
  // something happens
  break 10;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_looping_through_a_collection_with_for">looping through a collection with for</h4>
<div class="ulist">
<ul>
<li>
<p>we could use a <code>while</code> loop;</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>but this approach is error prone; program could panic if index or test
condition is wrong.</p>
</li>
<li>
<p>also slow; compiler adds runtime code to perform the conditional check
of whether the index is within the bounds of the array on every iter
through the loop.</p>
</li>
<li>
<p>more concise is to use <code>for</code> loop:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">for element in a {
  // do something
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>increased safety of code.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ch_4_understanding_ownership">ch 4: understanding ownership</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>enables Rust to make memory safety guarantees without needing a
garbage collector.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_4_1_what_is_ownership">4.1: what is ownership</h3>
<div class="ulist">
<ul>
<li>
<p>rust manages memory through a system of ownership with a set of rules
that compiler checks at compile time.</p>
</li>
<li>
<p>ownership features do not slow down program whiles it’s running.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_ownership_rules">ownership rules</h4>
<div class="ulist">
<ul>
<li>
<p>each value has a variable that’s called it’s owner</p>
</li>
<li>
<p>there can only be one owner at a time</p>
</li>
<li>
<p>when owner goes out of scope, value will be dropped</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_memory_and_allocation">memory and allocation:</h4>
<div class="sect4">
<h5 id="_move">move</h5>
<div class="ulist">
<ul>
<li>
<p><code>String::from</code>, requests memory it needs</p>
</li>
<li>
<p>when a variable goes out of scope, Rust called <code>drop</code>, is where author
of <code>String</code> can put the code to return the memory.</p>
</li>
<li>
<p>to ensure memory safety: after <code>let s2 = s1</code>, Rust considers <code>s1</code> to
no longer be valid; no need to free anything when <code>s1</code> goes out of
scope.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>move: shallow copy and invalidates the first variable.</p>
</li>
<li>
<p>Rust never automatically creates deep copies; any automatic copies are
assumed to be inexpensive.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_clone">clone</h5>
<div class="ulist">
<ul>
<li>
<p>deeply copy the heap data, not just stack data</p>
</li>
<li>
<p>expensive</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_copy">copy</h5>
<div class="ulist">
<ul>
<li>
<p>types that have known size at compile time are stored entirely on the
stack, so copies of actual type are quick to make.</p>
</li>
<li>
<p>there’s no reason we would want to prevent <code>x</code> from being valid after
creating <code>y</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>no difference between deep and shallow copy here.</p>
</li>
<li>
<p>Rust has special annotation called <code>Copy</code> trait that is placed on
types like integers.</p>
</li>
<li>
<p>Rust won’t let us annotate a type with <code>Copy</code> trait if the type or any
parts of it has implemented <code>Drop</code> trait.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ownership_and_functions">ownership and functions</h4>
<div class="ulist">
<ul>
<li>
<p>passing a <code>String</code>, s, to a function means that s is no longer valid,
the function <em>owns</em> s.</p>
</li>
<li>
<p>returning values can also transfer ownership.</p>
</li>
<li>
<p>ownership of a variable follows the same pattern: assigning a value to
another variable moves it.</p>
</li>
<li>
<p>when a variable that includes data on the heap goes out of scope, the
value will be cleaned up by <code>drop</code> unless the data has been moved to be
owned by another variable.</p>
</li>
<li>
<p>taking ownership and then returning ownership with every function is a
bit tedious.</p>
<div class="ulist">
<ul>
<li>
<p>what if we want to let a function use a value but not take ownership?</p>
</li>
</ul>
</div>
</li>
<li>
<p>anything we pass in also needs to be passed back if we want to use it
again.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>we can return multiple values in a tuple, and we need to return the
string so we can use it again later.</p>
</li>
<li>
<p>we solve that issue by using <em>references</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_4_2_references_and_borrowing">4.2 references and borrowing</h3>
<div class="ulist">
<ul>
<li>
<p>add <code>&amp;</code> to denote <em>references</em>, allow you to refer to some value
without taking ownership of it.</p>
<div class="ulist">
<ul>
<li>
<p>called borrowing: we cannot modify a borrowed value; <em>references</em> are
also immutable.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_mutable_references">mutable references</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>change the variable to be <code>mut</code>: <code>let mut s = String::from("hello")</code></p>
</li>
<li>
<p>create a mutable reference with <code>&amp;mut s</code> and call the <code>change</code>
function: <code>change(&amp;mut s)</code></p>
</li>
<li>
<p>update the function signature to accept mutable reference,
<code>some_string: &amp;mut String</code></p>
<div class="ulist">
<ul>
<li>
<p>but you can only have one mutable reference to a particular piece of
data at a time.</p>
</li>
<li>
<p>allows for mutation in a controlled fashion.</p>
</li>
<li>
<p>this prevents data races at compile time</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>a <em>data race</em> is similar to a race condition and occurs when: 1. two or
more pointers access the same data at the same time 2. at least one of
the pointers is being used to write to the data 3. there’s no mechanism
being used to synchronize access to the data</p>
</div>
<div class="paragraph">
<p>Rust won’t even compile code with data races! - we can use curly braces
to create a new scope.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_using_structs_to_structure_related_data">5: Using Structs to Structure Related Data</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_defining_and_instantiating_structs">5.1 Defining and Instantiating Structs</h3>
<div class="ulist">
<ul>
<li>
<p>more flexible than tuples.</p>
</li>
<li>
<p>use the init shorthand to above being repetitive.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_creating_instances_from_other_instances_with_struct_update_syntax">Creating Instances From Other Instances With Struct Update Syntax</h4>
<div class="ulist">
<ul>
<li>
<p><code>..</code> specifies that the remaining fields not explicitly set should
have the same value as the fields in the given instance.</p>
<div class="ulist">
<ul>
<li>
<p>must come last</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If we did:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let user2 = User {
  email: String::from("yeet@dab.com"),
  ..user1
  }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>this means user1 is not longer usable</p>
<div class="ulist">
<ul>
<li>
<p>but if there are traits that use the <code>Copy</code> trait, then user1 is
still valid</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_unit_like_structs_without_any_fields">Unit-Like Structs Without Any Fields</h4>
<div class="ulist">
<ul>
<li>
<p>useful when you need to implement a trait on some type bot don’th ave
any data that you want to store in the type itself</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_method_syntax">5.2: Method Syntax</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>first parameter is always self in the form <code>self</code>, <code>&amp;self</code>,
<code>&amp;mut self</code></p>
</li>
<li>
<p>to define function within context of a Struct, start with an <code>impl</code>
block.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_associated_functions">Associated functions</h3>
<div class="ulist">
<ul>
<li>
<p>don’t have <code>self</code>, so aren’t methods because they don’t need an
instance of the type to work with.</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

let sq = Rectangle::square(3);</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>you can have multiple <code>impl</code> blocks</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_enums_and_pattern_matching">6. Enums and Pattern Matching</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>enums allow you to define a type by enumerating it’s possible
variants.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_6_1_defining_an_enum">6.1. Defining an Enum</h3>
<div class="paragraph">
<p>IP addresses are either V4 or V6, but not both.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">enum IpAddrKind {
  V4,
  V6
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>create instances of enum:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let four = IpAddrKind::V4;
let six = IpAddrKind::V6;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>four</code> and <code>six</code> have the same type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to represent data, might put a enum in a struct. but can put data
directly into each enum variant.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">enum IpAddrKind {
  V4(String),
  V6(String)
}

let four = IpAddrKind::V4(String::from("111"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>another advantage to using enums rather than a struct is that each
variant can have different types and amounts of associated data.</p>
</div>
<div class="sect3">
<h4 id="_the_option">The <code>Option</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you have to convert <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code>
operations with it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_2_the_match_control_flow_construct">6.2 the <code>match</code> Control Flow Construct</h3>
<div class="ulist">
<ul>
<li>
<p>match arms can bind to parts of the values that match the pattern;
this is how values are extracted out of enum variants.</p>
</li>
<li>
<p>matches are exhaustive</p>
</li>
<li>
<p><code>catch</code> catches everything else</p>
</li>
<li>
<p><code>_</code> catches any value and does not bind to that value</p>
<div class="ulist">
<ul>
<li>
<p><code>_ ⇒ ()</code>: do nothing</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_6_3_concise_control_flow_with_if_let">6.3. Concise Control Flow with <code>if let</code></h3>
<div class="ulist">
<ul>
<li>
<p>handle values that match one pattern while ignoring the rest</p>
</li>
<li>
<p>lose exhaustive checking that <code>match</code> enforces</p>
</li>
<li>
<p>can use <code>else</code> to make exhaustive</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_managing_growing_projects_with_packages_crates_and_modules">7. Managing Growing Projects with Packages, Crates and Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>the module system: - packages: cargo feature that lets you build, test,
and share crates - crates: tree of modules that produces a library or
executable - modules and use: let you control the org, scope, and
privacy of paths - paths: a way of naming an item, such as a struct,
function, or module</p>
</div>
<div class="sect2">
<h3 id="_projectcrates">project/crates</h3>
<div class="ulist">
<ul>
<li>
<p>crate: binary or library</p>
<div class="ulist">
<ul>
<li>
<p>crate root: source file that Rust compiler starts from</p>
</li>
</ul>
</div>
</li>
<li>
<p>package: one or more creates that provide set of functionality;
package contains a <code>Cargo.toml</code> file that describes how to build those
crates</p>
<div class="ulist">
<ul>
<li>
<p>can contain at most one library crate</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_modules">modules</h3>
<div class="ulist">
<ul>
<li>
<p><code>src/main.rs</code>, <code>src/lib.rc</code>: crate roots</p>
<div class="ulist">
<ul>
<li>
<p>contents of either of these two files form a module called <code>crate</code> at
root of the crate’s module structure, known as the module tree.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>use</code>: brings a path into scope</p>
</li>
<li>
<p><code>pub</code>: makes items public</p>
</li>
<li>
<p><code>mod</code>: define module with</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_paths">paths</h3>
<div class="ulist">
<ul>
<li>
<p>two forms:</p>
<div class="ulist">
<ul>
<li>
<p>absolute: starts from crate root by using crate name or literal
<code>crate</code></p>
</li>
<li>
<p>relative: starts from current module and uses <code>self</code>, <code>super</code>, or an
identifier in the current module</p>
</li>
</ul>
</div>
</li>
<li>
<p>both types of paths followed by one or more identifiers separated by
double colons <code>::</code></p>
</li>
<li>
<p>all items are private by default</p>
</li>
<li>
<p>items in parent module can’t use the private items inside child
modules, but items in child modules can use the items in their ancestor
modules</p>
<div class="ulist">
<ul>
<li>
<p>child modules can see the context in which they’re defined</p>
</li>
<li>
<p>hiding inner implementation details is the default</p>
</li>
<li>
<p>expose inner parts of child modules’ code to outer ancestor modules
by using the <code>pub</code> keyword to make an item public</p>
</li>
</ul>
</div>
</li>
<li>
<p>adding <code>pub</code> to the module makes the module public but it’s contents
are still private; only code in its ancestor modules can refer to it</p>
</li>
<li>
<p>using <code>super</code> with relative paths is like using <code>..</code></p>
</li>
<li>
<p>adding <code>pub</code> to struct makes struct public but fields are still
private</p>
</li>
<li>
<p>if we make enum public then all of its variants are public</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_use">use</h3>
<div class="ulist">
<ul>
<li>
<p>to use module without the long path names</p>
</li>
<li>
<p>functions: bring in function’s parent module ⇒ makes it clear the
function isn’t locally defined</p>
</li>
<li>
<p>structs, enums, other items: specify full path name</p>
</li>
<li>
<p>provide new name with <code>as</code>, like Python</p>
</li>
<li>
<p>reexporting: combine <code>pub</code> and <code>use</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_common_collections">8. Common Collections</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>unlike built in arrays/tuples, these collections have their data
stored on the heap, so the amount of data doesn’t need to be known at
compile time and data can grow and shrink as program runs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>3 common types: - vector: store variable number of values next to each
other - string: collection of charterers - hash map: associate value
with particular key</p>
</div>
<div class="sect2">
<h3 id="_vector_vect">vector <code>Vec&lt;T&gt;</code>:</h3>
<div class="ulist">
<ul>
<li>
<p>only store values of same type</p>
</li>
<li>
<p><code>vec!</code> macro which creates a new vector that holds values you give it</p>
</li>
<li>
<p>dropping a vector drops it’s elements</p>
</li>
<li>
<p>access elements through <code>[]</code> (less safe) or <code>get()</code> (more safe)</p>
</li>
<li>
<p>same rule of not being able to have mutable and immutable references
applies for vectors:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0]; // immutable borrow

v.push(6); // mutable borrow

println!("The first element is: {}", first);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>doesn’t work because of how vectors work: vectors put values next to
each other in memory</p>
<div class="ulist">
<ul>
<li>
<p>adding a new element onto the end might require allocating new memory
and copying old elements into new space, then <code>first</code> would be pointing
to deallocated memory</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_string">String</h3>
<div class="ulist">
<ul>
<li>
<p>string slice <code>str</code> or <code>&amp;str</code></p>
</li>
<li>
<p>`String`type: growable, mutable, owned, UTF-8 encoded string type</p>
<div class="ulist">
<ul>
<li>
<p><code>String::from</code> and <code>to_string</code> do the same thing</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust strings don’t support indexing - <code>String</code> is wrapper over <code>Vec&lt;u8&gt;</code>
- index into a string’s bytes will not always correlate with valid
Unicode scalar value - if &amp;``hello''[0] were valid code that returned
the byte value, it would return 104, not h - three ways to look at
strings: bytes, scalar values and grapheme clusters - indexing
operations are expected to take constant time <code>O(1)</code>, but it’s not
possible because Rust has to walk thought the contents to determine how
many valid characters there are - can use range to create string slices,
but can crash your program - be explicit if you want <code>chars</code> or <code>bytes</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_hash_maps_hashmapk_v">Hash Maps <code>HashMap&lt;K, V&gt;</code></h3>
<div class="ulist">
<ul>
<li>
<p>store data on the heap</p>
</li>
<li>
<p>ways to construct:</p>
<div class="ulist">
<ul>
<li>
<p><code>use</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use std::collections:HashMap;

let mut map = HashMap::new();

mut.insert(String::from("Yeet"), 1);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>iterators and <code>collect</code> method on vector of tuples</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use std::collections:HashMap;

let keys = vec![String::from("A"),String::from("B")];
let vals = vec![1,2];

let mut map: HashMap&lt;_._&gt; = keys.into_iter().zip(vals.into_iter()).collect();</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>uses <em>SipHash</em> which provides resistance to DoS attacks but is not the
fastest hashing function.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_error_handling">9. Error Handling</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>does not have exceptions, has:</p>
<div class="ulist">
<ul>
<li>
<p><code>Result&lt;T ,E&gt;</code> for recoverable errors</p>
</li>
<li>
<p><code>panic!</code> macro that stops execution when the program encounters an
unrecoverable error</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_panic_macro"><code>panic!</code> macro</h3>
<div class="ulist">
<ul>
<li>
<p>when <code>panic!</code> macro executes, program will print fail message, unwind
and clean stack, then quit</p>
</li>
<li>
<p>the stack can either be:</p>
<div class="ulist">
<ul>
<li>
<p>unwind: Rust walks back up the stack and cleans up the data from each
function it encounters, however, this is a lot of work</p>
</li>
<li>
<p>abort: ends program without cleaning up; the memory will need to be
cleaned by the operating system</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_recoverable_errors_with_result">recoverable errors with <code>Result</code></h3>
<div class="ulist">
<ul>
<li>
<p>two generic type parameters: <code>T</code>, type of value that will be returned
in success case within <code>Ok</code> variant, and <code>E</code>, type of error that will be
returned in failure case within <code>Err</code> variant.</p>
</li>
<li>
<p>can use <code>match</code> on the <code>Results</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_shortcuts_for_panic_on_error_unwrap_and_expect">shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></h3>
<div class="ulist">
<ul>
<li>
<p><code>unwrap</code>: if <code>Result</code> value is:</p>
<div class="ulist">
<ul>
<li>
<p><code>Ok</code>: return value inside <code>Ok</code></p>
</li>
<li>
<p><code>Err</code>: call <code>panic!</code> macro</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>expect</code>: let’s us choose our own error message</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_shortcut_for_propagating_errors">shortcut for propagating errors:</h3>
<div class="ulist">
<ul>
<li>
<p><code>?</code> placed after <code>Result</code> value is defined to work in almost the same
way as <code>match</code></p>
<div class="ulist">
<ul>
<li>
<p>difference: error values that have <code>?</code> called on them go through the
<code>from</code> function, which is used to convert errors from one type into
another</p>
<div class="ulist">
<ul>
<li>
<p>the error type received is converted into the error type defined in
the return type <mark>#</mark> where <code>?</code> can be used</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>can only be used in functions whose return type of compatible with the
value the <code>?</code> is used on</p>
</li>
<li>
<p>you can use <code>?</code> on a <code>Result</code> in a function that returns <code>Result</code></p>
</li>
<li>
<p>you can use <code>?</code> on an <code>Option</code> in a function that returns <code>Option</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_10_generic_types_traits_and_lifetimes">10. Generic Types, Traits and Lifetimes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_in_method_definitions">in method definitions</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Methods written within an <code>impl</code> that declares the generic type will
be defined on any instance of the type, no matter what concrete type
ends up substituting for the generic type.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>means only the type <code>Point&lt;f32&gt;</code> will have this method defined.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_performance_of_code_using_generics">performance of code using generics</h3>
<div class="ulist">
<ul>
<li>
<p>code with generics doesn’t run any slower</p>
</li>
<li>
<p>Rust performs monomorphization: process of turning generic code into
specific code by filling in the concrete types</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_traits">Traits</h4>
<div class="ulist">
<ul>
<li>
<p>use traits to define shared behaviour in abstract way.</p>
</li>
<li>
<p>use trait bounds to specify that a generic type can be any type that
has certain behaviour</p>
</li>
<li>
<p>similar to interfaces in other languages</p>
</li>
<li>
<p>we can implement a trait on a type only if at least one of the trait
or the type is local to our crate</p>
<div class="ulist">
<ul>
<li>
<p>can’t implement external traits on external types</p>
<div class="ulist">
<ul>
<li>
<p>coherence, orphan rule ⇒ parent type is not present</p>
</li>
<li>
<p>rule ensures other people’s code can’t break your code</p>
</li>
<li>
<p>without rule, two creates could implement same trait for the same
type, and Rust wouldn’t know which implementation to use</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>can’t call default implementation from overriding implementation of
same method.</p>
</li>
<li>
<p>trait bounds:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>multiple trait bounds with +:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">pub fn notify(item: &amp;(impl Summary + Display)) {
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>clearer trait bounds with <code>where</code> Clauses</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>can only return a single type (even if the trait is in the return)</p>
</li>
<li>
<p>can use traits to conditionally implement methods</p>
</li>
<li>
<p>can also conditionally implement a trait for any type that implements
another trait</p>
<div class="ulist">
<ul>
<li>
<p>implementations of a trait on any type that satisfies the trait
bounds are called <em>blanket implementations</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validating_references_with_lifetimes">validating references with lifetimes</h3>
<div class="ulist">
<ul>
<li>
<p>main aim is to prevent dangling pointers</p>
</li>
<li>
<p>Rust determines code has gone out of scope with a borrow checker</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_generic_lifetimes_in_functions">generic lifetimes in functions</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>this code doesn’t compile; we don’t know if <code>&amp;str</code> refers to <code>x</code> or
<code>y</code>.</p>
</li>
<li>
<p>borrow checker can’t check either; add generic lifetime parameters</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Lifetime Annotation Syntax</strong> - lifetime annotations don’t chance how
long any of the references live - lifetime annotations describe
relationships of the lifetimes of multiple references to each other
without affecting the lifetime</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>when we specify lifetime parameters, we’re not changing the lifetime
of values, only telling the borrow checked to reject any values that
don’t adhere to these restraints.</p>
</li>
<li>
<p>lifetime annotations become part of the contract of the function</p>
</li>
<li>
<p>return value lifetime needs to be related to the lifetime of something
(parameter or value created)</p>
</li>
<li>
<p>patterns programmed into Rust’s analysis of references: <em>lifetime
elision rules</em></p>
<div class="ulist">
<ul>
<li>
<p>set of particular cases that the compiler will consider, and if your
code fits these cases you don’t need to write lifetime explicitly</p>
</li>
</ul>
</div>
</li>
<li>
<p>input lifetime: lifetimes on functions or method parameters</p>
</li>
<li>
<p>output lifetime: lifetime on return values</p>
</li>
<li>
<p>three rules to figure out what lifetimes references have when there
aren’t explicit annotations:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>each parameter that is a reference gets its own lifetime parameter</p>
</li>
<li>
<p>second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters</p>
</li>
<li>
<p>there are multiple input lifetime parameters, but one of them is
<code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of self is
assigned to all output lifetime parameters</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>'static</code> lifetime, which means the reference can live for the entire
duration of the program</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_13_fp_features_iterators_and_closures">13. FP Features: Iterators and Closures</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>closure: anonymous function that capture their environment</p>
<div class="ulist">
<ul>
<li>
<p>can save in a variable or pass as arguments</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>let</code> statement means it contains the definition of an anonymous
function, but not the resulting value of calling the anonymous function</p>
</li>
<li>
<p>there aren’t type annotations in the closure definition</p>
</li>
<li>
<p>closures don’t require you to annotate types of the parameters or the
return type like <code>fn</code> functions do</p>
</li>
<li>
<p>type annotations are required for functions because they’re part of an
explicit interface exposed to users</p>
<div class="ulist">
<ul>
<li>
<p>important so everyone agrees on what types of values a function uses
and returns</p>
</li>
</ul>
</div>
</li>
<li>
<p>closures aren’t used in exposed interface like this. # 14. Cargo and
Crates.io</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_smart_pointers">15. Smart Pointers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_16_fearless_concurrency">16. Fearless Concurrency</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_17_oop_features_of_rust">17. OOP Features of Rust</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_18_patterns_and_matching">18. Patterns and Matching</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_19_advanced_features">19. Advanced Features</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_20_final_project_building_a_multithreaded_web_server">20. Final Project: Building A Multithreaded Web Server</h2>
<div class="sectionbody">

</div>
</div>

    </div>
    <p><a href="../../../archive/">◀ Back to posts</a></p>
</div>

        </main>
        
        <footer>
<center><p><a href="https://twitter.com/hoalycu" target="_blank">twitter</a> <a href="https://github.com/lhao03" target="_blank">github</a> <a href="https://www.linkedin.com/in/lucy-hao/" target="_blank">linkedin</a></p></center>
            Site powered by cats, 🍫 and 
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
