<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lucy H | The Computer Science Degree: Theory vs. Application</title>
  <link rel="stylesheet" href="../../css/main.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/scheme.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/onedark.min.css" />
  <script>
    hljs.highlightAll();
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  <link rel="preconnect" href="https://www.googletagmanager.com" />
  <link rel="preconnect" href="https://www.google-analytics.com" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-KDGPVMHC9Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-KDGPVMHC9Q");
  </script>

  <!-- basic favicon -->
  <link rel="icon" href="../../images/android-chrome-384x384.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../images/android-chrome-384x384.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../images/android-chrome-384x384.png" />
  <link rel="apple-touch-icon-precomposed" href="../../images/android-chrome-384x384.png" />
</head>

  <body>
    <header>
      <div class="logo">
        <a href="../../">
          <img src="../../images/android-chrome-384x384.png" style="padding-right: 10px" />
        </a>
      </div>
    </header>

    <main role="main">
      <h1>The Computer Science Degree: Theory vs. Application</h1>
      <div>
  
  <div class="header">
    Posted on May 11, 2022
    
  </div>
  <div class="tags">
    
    Tags: <a title="All pages tagged 'computer science'." href="../../tags/computer%20science/index.html">computer science</a>, <a title="All pages tagged 'computer science education'." href="../../tags/computer%20science%20education/index.html">computer science education</a>
    
  </div>
  <div class="content">
    <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_the_computer_science_degree_an_impromptu_and_informal_analysis">The Computer Science Degree: An impromptu and informal analysis</a>
<ul class="sectlevel2">
<li><a href="#_overall_observations">Overall Observations</a></li>
</ul>
</li>
<li><a href="#_the_different_types_of_schools">The Different Types of Schools</a>
<ul class="sectlevel2">
<li><a href="#_the_engineering_pointer_school">The Engineering (Pointer) School</a></li>
<li><a href="#_the_functional_programming_theory_school">The Functional Programming (Theory) School</a></li>
<li><a href="#_the_java_or_python_industry_school">The Java or Python (Industry) School</a></li>
<li><a href="#_why_make_the_distinction_between_pointer_and_industry_school">Why make the distinction between "Pointer" and "Industry" School?</a></li>
</ul>
</li>
<li><a href="#_are_computer_science_degrees_too_theoretical">Are Computer Science Degrees too Theoretical?</a></li>
</ul>
</div>
<div class="paragraph">
<p><em>Update: 2022-05-28</em></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
I talk about research and ideas in this blog post from a natural sciences/mathematical point of view. I’m not a researcher, so take my ideas with a grain of salt. I’m also trying to figure out for myself "What is Computer Science", so my ideas may be half-formed or contradictory.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The natural sciences, like physics, chemistry and biology, are based on
experiments which require vocational skills. But data curation and
collection is meaningless without the theory to understand the data. If
you want to develop vaccines or drugs, you need to study chemistry and
biology. If you want to find the next smallest particle (quark anyone?)
or far away planet, you need to study physics.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../images/cs-degree/quark.jpg" alt="Apparently this is evidence of a quark">
</div>
</div>
<div class="paragraph">
<p>If you want to do research, think beyond the scope of what is known, and
discover something new, then you need the theory, which means pursuing a
theoretical degree (or learning the theory yourself). A scientist needs
to think of ideas that don’t even exist. I believe theory allows you to
come up with ideas that are correct and novel; you can’t come up with
correct and novel ideas with just vocational skills. Thus, a scientist
has to be both correct and novel to be successful<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>Research has uncertain goals and uncertain rewards, which can scare
people, including the people who decide to pursue research. Some people
don’t care about being correct and novel, they might just care about
being correct. I would say being correct vs. <em>correct and novel</em> is the
difference between a chemical engineer and a chemist:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The old joke is that with chemistry you learn how to make a new
molecule, but with ChemE you learn how to make 800 tons of it as cheaply
as possible<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Of course, I’m not saying engineers can’t have novel and correct ideas,
but you can be successful as an engineer just by being correct. If
you’re a scientist who can’t think of novel ideas, it’s hard to be
successful.</p>
</div>
<div class="paragraph">
<p>Thus, people may enjoy a certain field, but have no interest in
advancing the field and that’s totally okay. Some people just take the
elements on the periodic table for granted; they don’t care to know
how electrons are "arranged" for molecules. However, the benzene’s arrangement of electrons is something I want to learn more about. On the
other hand, I think genetics is cool, but I have no interest in
understanding why certain alleles are closer to each other on a gene.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../images/cs-degree/benzene.png" alt="Notes on Benzene">
</div>
</div>
<div class="paragraph">
<p>In the case that people just want to be correct, they may choose to do
engineering. In terms of engineering, there are a lot of engineering
disciplines to choose from, like chemical engineering, electrical
engineering, computer engineering, environmental engineering, materials
engineering, civil engineering, petroleum engineering, and many more.
Compared to a degree in sciences like chemistry or biology, engineering
degrees are more applied, and more focussed on correctness rather than
preparing to discover new ideas. A chemist could probably work as a
materials engineer, but someone with a degree in materials engineering
would be more efficient and cheaper to employ. A materials engineer will
study chemistry and physics, including topics like atomic bonding,
electrochemistry, free energy, etc<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>. But a
chemistry major and materials engineering major will study atomic bonds
differently. For instance, a materials engineer will learn that ceramics
include metallic and van der waals bonds<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>
, and that would be the extent of a material engineer’s course material on
atomic bonding. A chemistry major would learn about <em>why</em> certain bonds
exist between molecules in the first place in a series of courses like
"Electronic Structure of Atoms and Molecules"<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> and "Introduction to Quantum Mechanics and
Spectroscopy"<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>. Engineers learn about processes to be efficient, correct and
useful to industry by producing goods.</p>
</div>
<div class="paragraph">
<p>The natural science degrees (chemistry, physics, biology, math) have
their place and the engineering degrees have their place. But what is
the computer science degree? I’ve noticed that computer science is
taught differently at universities, with the differences being quite
significant. At some universities, the computer science major is part of
the sciences, while at other universities computer science is part of
engineering. Some schools tend to teach more theory, while others are
more applied. This has led me to the question, <em>Should the computer
science degree prepare students to conceive novel and correct ideas or
prep them with the processes they need in a technology industry?</em>.
Well, let’s look at the computer science curriculum of some
universities.</p>
</div>
<div class="sect1">
<h2 id="_the_computer_science_degree_an_impromptu_and_informal_analysis">The Computer Science Degree: An impromptu and informal analysis</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
These thoughts are based on my experiences at UBC and any course information I could find online. I was able to easily find many course websites (which included a detailed syllabus, assignments, slides and labs) from USC and NU. I couldn’t find many course websites for UofT. Thus, take these thoughts with a grain of salt.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>UBC, USC, UofT and NU all offer the computer science degree as a
bachelor in science. However,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>at UBC (University of British Columbia), computer science is under the
Faculty of Science</p>
</li>
<li>
<p>at USC (University of Southern California), computer science is under
the Viterbi School of Engineering</p>
</li>
<li>
<p>at UofT (University of Toronto), computer science is under the Faculty
of Arts and Science (for the St. George Campus at least)</p>
</li>
<li>
<p>at NU (Northeastern University), computer science is under the Khoury
College of Computer Sciences</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Comparison of Core Computer Science Courses Required for the Degree</strong></p>
</div>
<div class="paragraph">
<p>I try to match the UBC version to other schools’ version.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">UBC</th>
<th class="tableblock halign-left valign-top">USC</th>
<th class="tableblock halign-left valign-top">UofT</th>
<th class="tableblock halign-left valign-top">NU</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 110: Computation, Programs, and Programming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 102L:
Fundamentals of Computation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC108H1: Introduction to Computer
Programming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 2500: Fundamentals of Computer Science 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 121: Models of Computation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 170: Discrete Methods in Computer
Science</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC165H1: Mathematical Expression and Reasoning for Computer
Science</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 1800: Discrete Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 103L: Introduction to Programming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC148H1: Introduction to
Computer Science</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 2510: Fundamentals of Computer Science 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 210: Software Construction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 201L: Principles of Software
Development</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC207H1: Software Design</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 3500: Object-Oriented Design</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 221: Basic Algorithms and Data Structures</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 104L: Data
Structures and Object Oriented Design</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC236H1: Introduction to the
Theory of Computation/CSC263H1: Data Structures and Analysis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 320: Intermediate Algorithm Design and Analysis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 270:
Introduction to Algorithms and Theory of Computing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC373H1: Algorithm
Design, Analysis &amp; Complexity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 3000: Algorithms and Data/CS 3800:
Theory of Computation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 213: Introduction to Computer Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 356: Introduction to
Computer Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC258H1: Computer Organization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 310: Introduction to Software Engineering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 310: Software
Engineering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Co-op or 1 out of the project/inquiry based courses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS
4500: Software Development</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPSC 313: Computer Hardware and Operating Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 350:
Introduction to Operating Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSC209H1: Software Tools and Systems
Programming/CSC369H1: Operating Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 3650: Computer Systems</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 360: Introduction to Artificial Intelligence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CS 2810:
Mathematics of Data Models</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSCI 353: Introduction to Internetworking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CY 4740: Network
Security</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CY 2550: Foundations of Cybersecurity</p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_overall_observations">Overall Observations</h3>
<div class="paragraph">
<p>After I compared computer science course offerings<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>,<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>,<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>,<sup class="footnote" id="_footnote_nu-cs">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup> and the computer science core curriculum from each university, here are some things that jump out to me:</p>
</div>
<div class="sect3">
<h4 id="UBC-CS">UBC<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>:</h4>
<div class="ulist">
<ul>
<li>
<p>introductory computer science course taught in functional paradigm</p>
</li>
<li>
<p>there is a large focus on <em>functional programming</em> which is regarded
as more "theoretical" due to its mathematical nature</p>
<div class="ulist">
<ul>
<li>
<p>the result of a larger focus on functional programming means students
engage more with concepts like recursion</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>students are introduced to pointers and memory management in the
second year, later than other universities</em></p>
</li>
<li>
<p>students must learn a lot more programming languages including BSL
(dialect of Racket), Java, C, C++, etc.</p>
</li>
<li>
<p>UBC has recently released a industry focussed course called "Applied
Industry Practices"", though it’s only offered in the summer</p>
<div class="ulist">
<ul>
<li>
<p>thus UBC does not have as many industry/skills type of courses as
other universities</p>
</li>
</ul>
</div>
</li>
<li>
<p>compilers course is based on functional paradigm (Racket)<sup class="footnote" id="_footnote_411">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="UofT-CS">UofT<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>:</h4>
<div class="ulist">
<ul>
<li>
<p>uses Python as first programming language</p>
</li>
<li>
<p>no need for students to take explicit software engineering course if
they have done co-op. They can also choose out of a list of courses
(meaning they don’t need to do a software engineering course)</p>
</li>
<li>
<p>courses tend to use Python and C for systems courses, and Java for OOP
course</p>
</li>
<li>
<p>as a result of programming language choices, courses are <em>more OOP and
imperative based</em></p>
</li>
<li>
<p>has more industry type of courses like "Programming on the Web",
"Natural Language Computing", "High-Performance Scientific Computing"</p>
</li>
<li>
<p><em>students are introduced to OOP first and imperative programming first
(no recursion, pointers or memory management like UBC and USC)</em></p>
</li>
<li>
<p>compilers course is based on imperative paradigm (Using Python?)<sup class="footnote" id="_footnote_488">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="USC-CS">USC<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>:</h4>
<div class="ulist">
<ul>
<li>
<p>uses C++ as first programming language</p>
</li>
<li>
<p>courses seem more continuous, with 103L following right off from the
end of 102L.</p>
<div class="ulist">
<ul>
<li>
<p>probably because C is used, and C fits nicely with the operating
systems course, data structures, and algorithms course</p>
</li>
<li>
<p>only other language used is Java for OOP</p>
</li>
</ul>
</div>
</li>
<li>
<p>required to take ENGR 102, the engineering first-year students academy</p>
</li>
<li>
<p>required to take Introductions to AI and Internetworking</p>
</li>
<li>
<p>choice of choosing a capstone course of either "Design and
Construction of Large Software Systems" or "Creating Your High-Tech Startup"</p>
</li>
<li>
<p>required to take an embedded systems course</p>
</li>
<li>
<p>has many "skills" focussed courses like "Professional C++",
"Native Console Multiplayer Game Development", "Programming Graphical
User Interfaces"</p>
</li>
<li>
<p>also has more industry type of courses like "Creating Your High-Tech Startup"</p>
</li>
<li>
<p><em>students are introduced to pointers and memory management in their
first year, while they are introduced to recursion/functional
programming in their second/third year</em></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="NU-CS">Northeastern<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup></h4>
<div class="ulist">
<ul>
<li>
<p>first year computer science course is similar to UBC’s</p>
</li>
<li>
<p>two fundamentals courses (2500 and 2510), whereas UBC only has one
(CPSC 110), before the OOP course</p>
</li>
<li>
<p>students are required to do a security course</p>
</li>
<li>
<p>there are both theoretical and proof based courses like computer-aided
reasoning, verification, synthesis. I haven’t seen other universities
have these type of courses at the undergrad level</p>
</li>
<li>
<p>there are also more industry and skills focussed courses like mobile
development and web development.</p>
</li>
<li>
<p>there are several concentrations a student can choose to do, including
concentrations that are more theoretical and concentrations that are
more industry focussed.</p>
</li>
<li>
<p>only one low level course required</p>
</li>
<li>
<p>a theory of computation course is required</p>
</li>
<li>
<p>there is also a statistics/mathematics course that is tailored for the
computer science major: "Studies the methods and ideas in linear
algebra, multivariable calculus, and statistics that are most relevant
for the practicing computer scientist doing machine learning, modeling,
or hypothesis testing with data"</p>
</li>
<li>
<p>students learn about Turing machines, Church-Turing thesis, automata
as part of their version of CPSC 320. Students at UBC can also learn
about the mentioned concepts but in another course (so it’s optional)</p>
</li>
<li>
<p>there is a strong theory base for computer science degrees, but after
that your degree can be theoretical or industry/skills focussed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Canada, computer science seems to be treated closer to science,
meaning students don’t take many computer engineer-like courses. In the
USA, computer science seems to be treated more as engineering, meaning
students usually take a few low level hardware/systems courses that
electrical and computer engineers take.</p>
</div>
<div class="paragraph">
<p>Each university’s core curriculum are pretty similar in regards to courses in
operating systems, systems programming/computer systems/computer
organization. I’m guessing this is because many universities will teach
students about the Linux operating system. This is probably because
Linux is open sourced so it’s easier for professors and students to
access (they can access Linux through university servers), and how
there’s basically only two operating systems Linux (Unix/MacOS) and
Windows. Of course there are differences between Linux and MacOS, but
the general categories of operating systems will be Unix and Windows.
Additionally, since most systems programming has been done in C, 99% of
the time C is the language of choice for these courses.</p>
</div>
<div class="paragraph">
<p>For data structure and algorithm courses: At UBC, C is used for CPSC
221. USC also uses C for CSCI 104L. At UofT, I can’t seem to find what
CSC263H1 is taught in, so I will assume no programming language is used,
thought I may be completely wrong on this. NU also doesn’t seem to use a
programming language in their data structures and algorithms course.
Other then that, the data structures and algorithms course is pretty
similar in content between schools.</p>
</div>
<div class="paragraph">
<p>What differs the most are the introductory computer science courses, and
they differ drastically.
UBC<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> and
NU’s<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup> introductory computer science course follows the HtDP
curriculum (that teaches a functional programming paradigm) using
teaching languages like BSL.
USC<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>
uses C++ and teaches low-level concepts and imperative programming.
UofT<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>
follows the book "Practical Programming (3rd ed): An Introduction to
Computer Science Using Python 3" using Python to teach a bit of OOP but
not really anything about pointers or functional programming(?).</p>
</div>
<div class="paragraph">
<p>Additionally, some schools like UofT, USC and NU offer "pathways"
which list suggested/required courses a student should take. For
instance, there are specializations like "HCI", "Systems",
"Foundations", etc. UBC doesn’t have something like this, but students
could form their own pathway (it’s just not as explicit). These pathways
allow students to choose if they want their degree to be more theory
based or skills based.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_different_types_of_schools">The Different Types of Schools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There’s a school of thought that functions are either pointers or
values. A C programmer would say "well functions are simply pointers in
memory". A Racket or ML programmer would say "well we treat functions
just like data, so they are values". What about the Java or Python
programmer? Well, I’m not sure. An introductory computer science course
usually falls within one (or neither) of these schools.</p>
</div>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The TAs for the class I'm teaching, Principles of Imperative Computation, got me a &quot;Functions are Pointers&quot; jacket. (These jackets are in opposition to the &quot;Functions are Values&quot; jackets from the functional programming TAs.) I now wear it to point at functions. <a href="https://t.co/godT7tPf2g">pic.twitter.com/godT7tPf2g</a></p>&mdash; ✨ Jean Yang ✨ (@jeanqasaur) <a href="https://twitter.com/jeanqasaur/status/989578047757185025?ref_src=twsrc%5Etfw">April 26, 2018</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<div class="paragraph">
<p>I think the introductory computer science course, and higher year
courses a university offers, greatly influence a student’s degree, and
their perception of computer science. Based on how a university conducts
their introductory computer science course and the upper year offerings,
I’ve come up with three types of schools.</p>
</div>
<div class="sect2">
<h3 id="_the_engineering_pointer_school">The Engineering (Pointer) School</h3>
<div class="paragraph">
<p>Schools in the USA that classify computer science under engineering such
as USC fall into this category. The computer science degree will be
similar to the computer engineering degree in the first year, with
students learning C++ and some hardware-focussed courses like embedded
systems.</p>
</div>
<div class="paragraph">
<p>The Pointer school then uses C++ for majority of the computer science
courses, including the introductory computer science course. This means
students learn about pointers and memory management early on in
their computer science degrees. Theoretical concepts are covered in
later years of the degree.</p>
</div>
<div class="paragraph">
<p>Thus, the course is modeled around the programming language, rather than
the programming language being modeled around the concepts. As an
example, in the first computer science course at USC, students must
learn data representation of integers and strings before they can use
them in C; this is because C is a low-level language. Concepts are
more concrete rather than abstract, like learning about "passing
arrays". Someone learning functional programming doesn’t need to know
how integers and arrays are stored in memory or whether they should use
<code>u16</code> or <code>u32</code> in order to use an integer or array.</p>
</div>
<div class="paragraph">
<p>Engineering schools can also be industry schools because higher level
courses will offer more industry skills and focus on teaching
"fashionable programming languages and currently popular programming
paradigms"<sup class="footnote" id="_footnote_cs-does-not-matter">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_functional_programming_theory_school">The Functional Programming (Theory) School</h3>
<div class="paragraph">
<p>Schools like UBC or NU fall into this category, and teach the
introductory computer science course based on a systematic approach
(Structure and Interpretation of Programs/HtDP, UBC and NU both using HtDP)<sup class="footnote" id="_footnote_htdp">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup> using an
educational programming language in the functional programming paradigm.
This systematic approach stresses "explicit and systematic approaches
to program
design"<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup>, rather than worrying about number representation, pointers
and memory management that pointer/engineering schools would focus on. A
functional programming paradigm is usually used because it’s easier to
reason about: no mutation, data and state are separate, and it looks
similar to algebra (given an input, you get an output). Thus, there is a large
emphasis on forming well designed and correct programs and using
concepts like recursion which can be easily proved correct through
induction. Whereas to prove a <code>for loop</code> is correct you require more
steps. Many more theoretical concepts are covered, due to the simple
nature of the high level educational language, which allows students to
focus more on learning and practicing abstract or theoretical concepts
like recursion and higher order functions. In general, there is a focus
on aligning programming with mathematics, for instance by the
"composition of functions and expressions"<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>In regards to upper year offerings, NU has course offerings in
Computer-Aided Reasoning, Complexity Theory, and System Specification,
Verification, and Synthesis (to name a few). These types of courses are
more of the "formal" and "mathematical" nature, and rarely offered
to undergrads at other universities, including UBC! Even similar courses
can differ at a theory school. At UBC, the compiler course is taught in
Racket and centers around creating a compiler for a functional language,
whereas at UofT, the compiler course is taught in Python and the project is a compiler that
targets an imperative language.</p>
</div>
<div class="paragraph">
<p>A theory school provides you a stronger theory background, which is good
if you will plan to go into grad school or research.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_java_or_python_industry_school">The Java or Python (Industry) School</h3>
<div class="paragraph">
<p>I first learned about the concept when reading a paper<sup class="footnote" id="_footnote_principles-2-practice">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup>
about using teaching languages to introduce objects and
eventually OOP. While reading the references, I was intrigued by a blog
post called "The Perils of
JavaSchools"<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>, which is where I learned the concept of a
JavaSchool.</p>
</div>
<div class="paragraph">
<p>What is a JavaSchool, or more generally an "industry" school? An
industry school is one that teaches what is currently popular in
industry, aka "teaching fashionable programming languages and currently
popular programming paradigms"<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>. For the
introductory programming course, a popular mainstream programming
language like Java or Python along with a popular programming paradigm,
such as object orientated programming is taught. Concepts like pointers
or recursion are merely brushed over, or never even mentioned until the
systems course or the algorithms course.</p>
</div>
<div class="quoteblock">
<blockquote>
You may be wondering if teaching object oriented
programming (OOP) is a good weed-out substitute for pointers and
recursion. The quick answer: no. Without debating OOP on the merits, it
is just not hard enough to weed out mediocre programmers. OOP in school
consists mostly of memorizing a bunch of vocabulary terms like
“encapsulation" and "inheritance" and taking multiple-choice
quizzicles on the difference between polymorphism and overloading. Not
much harder than memorizing famous dates and names in a history class,
OOP poses inadequate mental challenges to scare away first-year
students. When you struggle with an OOP problem, your program still
works, it’s just sort of hard to maintain. Allegedly. But when you
struggle with pointers, your program produces the line Segmentation
Fault and you have no idea what’s going on, until you stop and take a
deep breath and really try to force your mind to work at two different
levels of abstraction simultaneously.
</blockquote>
<div class="attribution">
— Joel Spolsky<br>
<cite><a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">The Perils of JavaSchools</a></cite>
</div>
</div>
<div class="paragraph">
<p>I didn’t choose to attend UofT and UofC for computer science because
they were industry schools that taught OOP using Python in the
introductory computer science course, and many of their higher year
courses didn’t seem interesting to me. But they may seem interesting to
someone more industry orientated.</p>
</div>
<div class="paragraph">
<p>Another argument against teaching OOP in the introductory computer
science course is that the "complexity of object-orientated programming
bears little fruit"<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup> for first year students.</p>
</div>
<div class="quoteblock">
<blockquote>
It makes no sense to teach students how to engineer
structure of large programs when they are yet to write any programs with
a complexity worth structuring.
</blockquote>
<div class="attribution">
— Matthias Felleisen and Shriram Krishnamurthi<br>
<cite><a href="http://cs.brown.edu/~sk/Publications/Papers/Published/fk-why-cs-doesnt-matter/">Why Computer Science Doesn’t Matter</a></cite>
</div>
</div>
<div class="paragraph">
<p>Industry schools will also have upper year courses like "web
development", "mobile development", or computer science courses that
are also business oriented. USC, UofT and NU have courses like this.</p>
</div>
<div class="paragraph">
<p>With that being said, industry schools prepare you to with skills to
write software for the industry.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_make_the_distinction_between_pointer_and_industry_school">Why make the distinction between "Pointer" and "Industry" School?</h3>
<div class="paragraph">
<p>Computer engineering and computer science are frequently confused. Is
the operating system more part of computer science or web development?
Should computer science students learn how to interact with memory if
they probably won’t be writing code that uses Linux system calls?</p>
</div>
<div class="paragraph">
<p>Computer engineering is more associated with how a computer works, down
to the circuits and metal bits, in addition to assembly and C. Pointer
schools which classify computer science as part of engineering likely
have more low-level courses and an emphasis on low-level concepts.</p>
</div>
<div class="paragraph">
<p>On the other hand, an industry school sees computer science more for
being software that has been created with high-level languages like
Java. Thus, industry schools won’t focus on low-level concepts that
much, because popular languages like Java, Python and JavaScript have
abstracted away the details of memory.</p>
</div>
<div class="paragraph">
<p><em>This is how I would categorise the four schools I analyzed</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../images/cs-degree/schoolRadarChart.png" alt="schoolRadarChart">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_are_computer_science_degrees_too_theoretical">Are Computer Science Degrees too Theoretical?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>T frequently hear people complain that computer science degrees
are useless. This probably occurs more at UBC than other schools because
there aren’t many courses that contain "industry skills" like web
development. The only course that teaches web development technologies
at UBC (CPSC
455)<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> is only offered in the summer. UBC has many higher level theory
based courses, like Definition of Programming Languages (taught in
Racket), Introduction to Compiler Construction (which is applied because
there’s a project, but taught in (a functional paradigm) Racket, which
students may feel is more "theoretical" than say using Python like
UofT does), Numerical Linear Algebra, Computational Optimization and
Advanced Algorithms Design and Analysis to name a few. Besides the web
development course offer in the summer, there aren’t many courses that
directly teach "popular and hot"* industry skills at UBC.</p>
</div>
<div class="paragraph">
<p>*There are game development courses at UBC, but most computer science
students aren’t interested in game development due to the lower end
salary and grueling hours as compared to a Big Tech job.</p>
</div>
<div class="paragraph">
<p>Meanwhile, at USC, NU, and UofT there are many more courses that
directly teach industry skills. At USC, there are courses called
"Programming Graphical User Interfaces" and "Android App
Development". Similarly, UofT has "Programming on the Web",
"Designing Systems for Real World Problems", "The Business of
Software". At NU, students can choose to make their degree more
industry focussed or theory focussed, hence why NU is strong in both
theory and industry in the radar chart above.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../images/cs-degree/theory-vs-industry.png" alt="theory vs industry">
</div>
</div>
<div class="paragraph">
<p>In regards to the core computer science curriculum, NU’s is the most theory based. Students
learn about the Turing thesis for instance, which none of the other 3
universities require. Next is UBC. UBC’s focus on a functional paradigm
makes it more theory based than USC or UofT, which teach their
introductory computer science course with an low-level / OOP focus,
respectively. USC and UofT are close in terms of their core computer science curriculum, but
UofT edges USC over theory based on computer science course offerings;
UofT has more theory based higher level course offerings than USC. This
is just my observation.</p>
</div>
<div class="paragraph">
<p>Maybe you’re wondering why there’s so many differences in how
universities teach computer science. Different schools can really offer
a different computer science education to their students. Well I think
it’s because of the confusion of what computer science is.</p>
</div>
<div class="quoteblock">
<blockquote>
there is a widespread belief that computing science as
such has been all but completed and that, consequently, computing has
"matured" from a theoretical topic for the scientists to a practical
issue for the engineers, the managers and the entrepreneurs, i.e. mostly
people —and there are many of those!— who can accept the application of
science for the obvious benefits, but feel rather uncomfortable with its
creation because they don’t understand what the doing of research, with
its intangible goals and its uncertain rewards, entails.
</blockquote>
<div class="attribution">
— Edsger W. Dijkstra<br>
<cite><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1304.html">The end of Computing Science</a></cite>
</div>
</div>
<div class="paragraph">
<p>The question we need to ask then:</p>
</div>
<div class="paragraph">
<p><strong>Is the computer science degree for students who wish to pursue research
in computer science to think of correct and novel ideas, or for the
student who only cares about being correct and working in the
software industry?</strong></p>
</div>
<div class="paragraph">
<p>Currently, the computer science degree at many schools tries to do it
all: prepare students for grad school and prepare students to create web
applications in the software industry.</p>
</div>
<div class="paragraph">
<p>I don’t think this is good because one area severely lacking in many computer science degrees (not
in the curriculum or offered in higher level courses) is reasoning and
formal verification of systems and type theory, among other areas of theoretical science.
Dijkstra also thought the same many years ago!</p>
</div>
<div class="quoteblock">
<blockquote>
Until the end of his life, Dijkstra maintained that
the central challenges of computing hadn’t been met to his satisfaction,
due to an insufficient emphasis on program correctness (though not
obviating other requirements, such as maintainability and efficiency)
</blockquote>
<div class="attribution">
— <a href="https://en.wikipedia.org/wiki/On_the_Cruelty_of_Really_Teaching_Computer_Science">Wikipedia</a>
</div>
</div>
<div class="paragraph">
<p>I don’t think universities are equipping computer science students to do
research in areas like formal verification, dependent types, compiler
correctness and more. I also don’t think computer science degrees are
equipping students well for the industry either. There needs to be a
different path for computer scientists and software developers, like
there is for chemists and chemical engineers. Computer science is a
different subject than software
development<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>The question is then is the computer science degree too theoretical? <strong>If the computer
science degree is to prepare students to do research where they must think of
correct and novel ideas in the field of computer science, then no, the
computer science degree is not too theoretical. It actually isn’t
theoretical enough.</strong></p>
</div>
<div class="paragraph">
<p><em>Of course, this means there should be a different degree for people who want
to work in the software industry, with coursework that is more user focussed
and practical<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>, rather than theoretical. The issue is that
there’s no clear definition of the "Software Engineer" discipline like there is
for chemical engineering, so Computer Science is treated as a giant umbrella term.
While there are overlaps between the two fields, I believe they are distinct
enough to warrant a split.</em></p>
</div>
<div class="paragraph">
<p>For instance, we can all agree that software is laden with bugs and as
Dijkstra says:</p>
</div>
<div class="quoteblock">
<blockquote>
On the contrary, most of our systems are much more
complicated than can be considered healthy, and are too messy and
chaotic to be used in comfort and confidence. The average customer of
the computing industry has been served so poorly that he expects his
system to crash all the time, and we witness a massive worldwide
distribution of bug-ridden software for which we should be deeply
ashamed.
</blockquote>
<div class="attribution">
— Edsger W. Dijkstra"<br>
<cite><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1304.html">The end of Computing Science</a></cite>
</div>
</div>
<div class="paragraph">
<p>Verifying programs is hard. But everything is a program in computer
science! A compiler is a program that takes in a program and outputs
another program! It’s one thing to write a program, and another thing to
verify a program is both useful and correct.</p>
</div>
<div class="paragraph">
<p>I liken it to the production of drugs. It’s one thing to discover a
drug, and it’s another thing to synthesize that drug. Then it’s another
thing to learn how to synthesize that drug on a large scale as safely
and effectively as possible. Without someone who understands the theory,
you can’t think of a way of making a drug. For instance, an novice
chemistry student may find the formula to create a drug, and realise
they have unfortunately created stereoisomers of the drug. But only one
stereoisomer of the drug works; in most cases, the other stereoisomers
are not effective or even harmful. While there are ways to filter the
products, but this means you waste around half of your products, which
is not good because many drug precursors are byproducts of the oil and
gas
industry<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup>,
so we don’t have an infinite supply. This is a hard problem in
chemistry, the solution being awarded a 2021 Nobel Prize in
Chemistry<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../images/cs-degree/lemon.jpeg" alt="lemon">
</div>
</div>
<div class="paragraph">
<p>For a long time, drug makers were stuck having to filter out their
products for the correct stereoisomer. After years of research, there
are now ways to conduct "asymmetric organocatalysis", meaning you only
create one stereoisomer. Similarly to program verification, we are
currently stuck writing tests. But "testing cannot prove the absence of
bugs it can prove their
existence"<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup>. For now, we are just stuck writing
tests among tests and hoping for the best, like the novice chemistry
student was stuck just filtering out the products for the correct
stereoisomer.</p>
</div>
<div class="paragraph">
<p>How can the ability to easily verify a program is correct be achieved? How do we prove the absence of bugs so we don’t get
catastrophic scenarios like
NASA<sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup>
sometimes does? With research. Which requires a strong understanding of
theory. Right now, formal verification is an "unmastered complexity".
Many problems in computer science are an "unmastered complexity".</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>You see, while we all know that unmastered complexity is at the root of
the misery, we do not know what degree of simplicity can be obtained,
nor to what extent the intrinsic complexity of the whole design has to
show up in the interfaces. We simply do not know yet the limits of
disentanglement. We do not know yet whether intrinsic intricacy can be
distinguished from accidental intricacy. We do not know yet whether
trade-offs will be possible. We do not know yet whether we can invent
for intricacy a meaningful concept about which we can prove theorems
that help. <strong>To put it bluntly, we simply do not know yet what we should
be talking about, but that should not worry us, for it just illustrates
what was meant by "intangible goals and uncertain rewards"</strong>.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>So how do we figure out the "limits of disentanglement" and
"trade-offs"? By equipping students with the theory required to think
of correct and novel ideas.</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="http://www.paulgraham.com/think.html">How to Think for Yourself</a>
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. <a href="https://www.reddit.com/r/chemistry/comments/3gi2wl/chemical_engineering_vs_chemistry/">Chemical Engineering vs. Chemistry</a>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. <a href="https://mtrl.ubc.ca/undergraduate/current-students/course-lists-and-descriptions">Department of Materials Engineering:Course lists and descriptions</a>
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. <a href="https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=dWJjZml6ei5jb218d3d3fGd4OjNiODY2ZmQ0MGM4NzMyYTM">Bonding and Properties</a>
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. <a href="https://www.chem.ubc.ca/chemistry-412-structure-atoms-and-molecules">CHEM 412</a>
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. <a href="https://www.chem.ubc.ca/chemistry-312-introduction-quantum-mechanics-and-spectroscopy-15">CHEM 312</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. <a href="https://courses.students.ubc.ca/cs/courseschedule?pname=subjarea&amp;tname=subj-department&amp;dept=CPSC">UBC Computer Science Courses</a>
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. <a href="https://classes.usc.edu/term-20223/classes/csci">USC Computer Science Courses</a>
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. <a href="https://artsci.calendar.utoronto.ca/section/Computer-Science">UofT Computer Science Courses</a>
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. <a href="https://catalog.northeastern.edu/undergraduate/computer-information-science/computer-science/bscs/#programrequirementstext">NU CS Curriculum</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. <a href="https://www.calendar.ubc.ca/vancouver/index.cfm?tree=12,215,410,421">UBC CS Curriculum</a>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. <a href="https://www.students.cs.ubc.ca/~cs-411/2020w2/">CPSC 411</a>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. <a href="https://artsci.calendar.utoronto.ca/section/Computer-Science#programs">UofT CS Curriculum</a>
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. <a href="https://www.cs.toronto.edu/~pdm/csc488/winter2019/assignments/a3.html">CSC488</a>
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. <a href="https://www.cs.usc.edu/academic-programs/undergrad/computer-science/">USC CS Curriculum</a>
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. <a href="http://cs110.students.cs.ubc.ca/syllabus.html">CPSC110</a>
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. <a href="https://felleisen.org/matthias/Thoughts/Developing_Developers.html">Developing Developers</a>
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. <a href="https://ee.usc.edu/~redekopp/cs102/Fa21Syllabus.pdf">CS102</a>
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. <a href="https://www.cs.toronto.edu/dcs/ugdocs/course-outlines/2021/Fall/CSC108H1-Fall2021.pdf">CSCI108</a>
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/fk-why-cs-doesnt-matter/paper.pdf">Viewpoint: Why Computer Science Doesn’t Matter</a>
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. <a href="http://cs.brown.edu/~sk/Publications/Papers/Published/fffk-htdp-vs-sicp-journal/">HtDP vs. SICP</a>
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. <a href="https://felleisen.org/matthias/Thoughts/Developing_Developers.html">Developing Developers</a>
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. Tobin-Hochstadt, S., &amp; Van Horn, D. (2013). From Principles to Practice with Class in the First Year. Electronic Proceedings in Theoretical Computer Science, 136, 1–15. doi:10.4204/eptcs.136.1
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. <a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">The Perils of JavaSchools</a>
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. <a href="https://courses.students.ubc.ca/cs/courseschedule?sesscd=S&amp;campuscd=UBC&amp;pname=subjarea&amp;tname=subj-section&amp;sessyr=2022&amp;course=455&amp;section=901&amp;dept=CPSC">CPSC 455</a>
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. <a href="https://www.joelonsoftware.com/2005/01/02/advice-for-computer-science-college-students/">Advice for Computer Science College Students</a>
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. I differentiate between computer science and software development. I think software development is concerned with the user (creating products for users), implementation, practices (agile), etc. Computer science is concerned with theory such as such as the Church-Turing thesis, satisfiability modulo theories, formal verification, etc. There is now also the notion of "Software Engineering Research". Philp Guo gives a blurb on what his research during his Ph.D was about, which I think falls into Software Engineering research: "Research into software development tools for non-software engineers, but rather for scientists, engineers, and researchers who need to program for their jobs – they’re not gonna care about specs., model checking, etc. – they just want pragmatic, lightweight, and conceptually-simple tools that they can pick up quickly and use all the time."
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. <a href="https://emergency.cdc.gov/agent/benzene/basics/facts.asp">Benzene</a>
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. <a href="https://www.nobelprize.org/prizes/chemistry/2021/press-release">2021 Nobel Prize in Chemistry</a>
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. <a href="https://wiki.c2.com/?TestsCantProveTheAbsenceOfBugs">Tests Cant Prove The Absence Of Bugs</a>
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. <a href="https://ti.arc.nasa.gov/m/pub-archive/1338h/1338%20(Brat).pdf">NASA</a>
</div>
</div>

  </div>
  <div class="flex-row link-no-style">
    
    <a href="../../posts/notes/2022-05-23-os/index.html">⇐ Newer post</a>
    
    
    <a href="../../posts/notes/2022-05-09-fairness-abstraction/index.html">Older post ⇒</a>
    
  </div>
</div>


    </main>

    <footer>
      <center>
        <p>
          <a href="../../archive">archive</a>
          <a href="https://github.com/lhao03" target="_blank">github</a>
          <a href="https://www.linkedin.com/in/lucy-hao/" target="_blank">linkedin</a>
        </p>
      </center>
      Site powered by cats, 🍫 and
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>
